---@diagnostic disable: undefined-global, undefined-field
BookArchivist = BookArchivist or {}
BookArchivist.UI = BookArchivist.UI or {}

local ListUI = {}
BookArchivist.UI.List = ListUI

local ctx
local listBlock
local listHeader
local breadcrumb
local listSeparator
local searchBox
local scrollFrame
local scrollChild
local infoText
local booksModeButton
local locationsModeButton
local ROW_H = 44

local locationState = {
  path = {},
  rows = {},
  root = nil,
  activeNode = nil,
}

local LIST_MODES = {}
local ButtonPool = { free = {}, active = {} }

local function debugPrint(...)
  if ctx and ctx.debugPrint then
    ctx.debugPrint(...)
  end
end

local function logError(message)
  if ctx and ctx.logError then
    ctx.logError(message)
  end
end

local function getAddon()
  if not ctx or not ctx.getAddon then
    return nil
  end
  return ctx.getAddon()
end

local function rememberWidget(name, widget)
  if ctx and ctx.rememberWidget then
    return ctx.rememberWidget(name, widget)
  end
  return widget
end

local function getWidget(name)
  if ctx and ctx.getWidget then
    return ctx.getWidget(name)
  end
end

local function safeCreateFrame(frameType, name, parent, ...)
  if ctx and ctx.safeCreateFrame then
    return ctx.safeCreateFrame(frameType, name, parent, ...)
  end
  return nil
end

local function getListMode()
  if ctx and ctx.getListMode then
    return ctx.getListMode()
  end
  return LIST_MODES.BOOKS
end

local function setListMode(mode)
  if ctx and ctx.setListMode then
    ctx.setListMode(mode)
  end
end

local function getFilteredKeys()
  if ctx and ctx.getFilteredKeys then
    return ctx.getFilteredKeys()
  end
  return {}
end

local function getSelectedKey()
  if ctx and ctx.getSelectedKey then
    return ctx.getSelectedKey()
  end
  return nil
end

local function setSelectedKey(key)
  if ctx and ctx.setSelectedKey then
    ctx.setSelectedKey(key)
  end
end

local function disableDeleteButton()
  if ctx and ctx.disableDeleteButton then
    ctx.disableDeleteButton()
  end
end

local function notifySelectionChanged()
  if ctx and ctx.onSelectionChanged then
    ctx.onSelectionChanged()
  end
end

local function normalizeLocationLabel(label)
  if not label or label == "" then
    return "Unknown Location"
  end
  return label
end

local function getUI()
  if ctx and ctx.getUIFrame then
    return ctx.getUIFrame()
  end
end

local function buildLocationTreeFromDB(db)
  local root = {
    name = "__ROOT__",
    depth = 0,
    children = {},
    childNames = {},
  }

  if not db or not db.books then
    return root
  end

  local order = db.order or {}
  for _, key in ipairs(order) do
    local entry = db.books[key]
    if entry then
      local chain = entry.location and entry.location.zoneChain
      if not chain or #chain == 0 then
        local fallback = entry.location and entry.location.zoneText
        if fallback and fallback ~= "" then
          chain = { fallback }
        else
          chain = { "Unknown Location" }
        end
      end

      local node = root
      for _, segment in ipairs(chain) do
        local name = normalizeLocationLabel(segment)
        node.children = node.children or {}
        node.childNames = node.childNames or {}
        if not node.children[name] then
          node.children[name] = {
            name = name,
            depth = (node.depth or 0) + 1,
            parent = node,
            children = {},
            childNames = {},
            books = {},
          }
          table.insert(node.childNames, name)
        end
        node = node.children[name]
      end

      node.books = node.books or {}
      table.insert(node.books, key)
    end
  end

  local function sortNode(node)
    if not node or not node.childNames or #node.childNames == 0 then
      return
    end
    table.sort(node.childNames, function(a, b)
      return a:lower() < b:lower()
    end)
    for _, childName in ipairs(node.childNames) do
      sortNode(node.children and node.children[childName])
    end
  end

  sortNode(root)
  return root
end

local function ensureLocationPathValid()
  local root = locationState.root
  local path = locationState.path
  if not path then
    path = {}
    locationState.path = path
  end
  if not root then
    wipe(path)
    locationState.activeNode = nil
    return
  end

  local node = root
  for i = 1, #path do
    local segment = path[i]
    if node.children and node.children[segment] then
      node = node.children[segment]
    else
      for j = #path, i, -1 do
        table.remove(path, j)
      end
      break
    end
  end
  locationState.activeNode = node
end

local function rebuildLocationRowsForCurrentNode()
  local rows = {}
  local node = locationState.activeNode or locationState.root
  if not node then
    locationState.rows = rows
    return
  end

  local path = locationState.path or {}
  if #path > 0 then
    table.insert(rows, { kind = "back" })
  end

  local childNames = node.childNames or {}
  if childNames and #childNames > 0 then
    for _, childName in ipairs(childNames) do
      table.insert(rows, { kind = "location", name = childName, node = node.children and node.children[childName] })
    end
  else
    local books = node.books or {}
    for _, key in ipairs(books) do
      table.insert(rows, { kind = "book", key = key })
    end
  end

  locationState.rows = rows
end

local function getLocationBreadcrumbText()
  local path = locationState.path or {}
  if #path == 0 then
    return "All locations"
  end
  return table.concat(path, " > ")
end

local function pushLocationSegment(segment)
  segment = normalizeLocationLabel(segment)
  if segment == "" then return end
  local path = locationState.path or {}
  locationState.path = path
  path[#path + 1] = segment
  ensureLocationPathValid()
  rebuildLocationRowsForCurrentNode()
end

local function popLocationSegment()
  local path = locationState.path
  if not path or #path == 0 then return end
  table.remove(path)
  ensureLocationPathValid()
  rebuildLocationRowsForCurrentNode()
end

local function entryToDisplay(entry)
  local title = entry.title or "(Untitled)"
  local creator = entry.creator or ""

  local titleColor = "|cFFFFD100"
  if entry.material and entry.material:lower():find("parchment") then
    titleColor = "|cFFE6CC80"
  end

  local result = titleColor .. title .. "|r"

  if creator ~= "" then
    result = result .. "\n|cFF999999   " .. creator .. "|r"
  end

  return result
end

local function makeRow()
  local parent = scrollChild or getWidget("scrollChild")
  local button = CreateFrame("Button", nil, parent)
  button:SetSize(340, ROW_H)

  button.bg = button:CreateTexture(nil, "BACKGROUND")
  button.bg:SetAllPoints(true)
  button.bg:SetColorTexture(0, 0, 0, 0)

  button.highlight = button:CreateTexture(nil, "HIGHLIGHT")
  button.highlight:SetAllPoints(true)
  local hasAtlas = pcall(function() button.highlight:SetAtlas("search-highlight") end)
  if not hasAtlas then
    button.highlight:SetColorTexture(1, 1, 1, 0.1)
  end
  button.highlight:SetAlpha(0.5)

  button.selected = button:CreateTexture(nil, "BACKGROUND", nil, 1)
  button.selected:SetAllPoints(true)
  local hasSelAtlas = pcall(function() button.selected:SetAtlas("groupfinder-button-cover") end)
  if not hasSelAtlas then
    button.selected:SetColorTexture(0.2, 0.4, 0.8, 0.3)
  end
  button.selected:SetAlpha(0.7)
  button.selected:Hide()

  button.selectedEdge = button:CreateTexture(nil, "OVERLAY")
  button.selectedEdge:SetSize(2, ROW_H - 2)
  button.selectedEdge:SetPoint("LEFT", 2, 0)
  button.selectedEdge:SetColorTexture(1, 0.82, 0, 1)
  button.selectedEdge:Hide()

  button.text = button:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
  button.text:SetPoint("TOPLEFT", 10, -6)
  button.text:SetPoint("BOTTOMRIGHT", -10, 6)
  button.text:SetJustifyH("LEFT")
  button.text:SetJustifyV("TOP")
  button.text:SetWordWrap(true)
  button.text:SetMaxLines(2)

  button:SetScript("OnClick", function(self)
    if SOUNDKIT and SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON then
      PlaySound(SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON)
    end

    if getListMode() == LIST_MODES.LOCATIONS then
      if self.itemKind == "location" and self.locationName then
        pushLocationSegment(self.locationName)
        ListUI:UpdateList()
        ListUI:UpdateListModeUI()
        return
      elseif self.itemKind == "back" then
        popLocationSegment()
        ListUI:UpdateList()
        ListUI:UpdateListModeUI()
        return
      end
    end

    if self.bookKey then
      setSelectedKey(self.bookKey)
      notifySelectionChanged()
      ListUI:UpdateList()
    end
  end)

  return button
end

local function resetButton(button)
  button:Hide()
  button:ClearAllPoints()
  button.bookKey = nil
  button.itemKind = nil
  button.locationName = nil
  if button.selected then button.selected:Hide() end
  if button.selectedEdge then button.selectedEdge:Hide() end
end

function ButtonPool:Acquire()
  local button = table.remove(self.free)
  if not button then
    button = makeRow()
    debugPrint("[BookArchivist] ButtonPool: created new row button")
  end
  button:Show()
  table.insert(self.active, button)
  return button
end

function ButtonPool:ReleaseAll()
  for _, button in ipairs(self.active) do
    resetButton(button)
    table.insert(self.free, button)
  end
  wipe(self.active)
end

local function matches(entry, q)
  if q == "" then return true end
  q = q:lower()

  local function has(s)
    s = (s or ""):lower()
    return s:find(q, 1, true) ~= nil
  end

  if has(entry.title) or has(entry.creator) or has(entry.author) then
    return true
  end

  if entry.pages then
    for _, t in pairs(entry.pages) do
      if has(t) then return true end
    end
  end
  return false
end

local function ensureInfoText()
  if infoText and infoText:GetObjectType() == "FontString" then
    infoText:Show()
    return infoText
  end
  if not listBlock then
    return nil
  end
  infoText = listBlock:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
  infoText:SetPoint("BOTTOM", listBlock, "BOTTOM", 0, 6)
  infoText:SetText("|cFF00FF00Tip:|r Open books normally - pages save automatically")
  rememberWidget("infoText", infoText)
  return infoText
end

local function getSearchText()
  local box = searchBox or getWidget("searchBox")
  if not box then
    return ""
  end
  return box:GetText() or ""
end

function ListUI:Init(context)
  ctx = context or {}
  LIST_MODES = ctx.listModes or {}
end

function ListUI:SetCallbacks(cb)
  ctx = ctx or {}
  ctx.onSelectionChanged = cb and cb.onSelectionChanged or ctx.onSelectionChanged
  ctx.disableDeleteButton = cb and cb.disableDeleteButton or ctx.disableDeleteButton
end

function ListUI:GetListBlock()
  return listBlock
end

function ListUI:Create(uiFrame)
  if not uiFrame then
    return
  end
  self.uiFrame = uiFrame
  local container = CreateFrame("Frame", nil, uiFrame)
  container:SetPoint("TOPLEFT", uiFrame, "TOPLEFT", 58, -28)
  container:SetPoint("TOPRIGHT", uiFrame, "TOPRIGHT", -30, -28)
  container:SetHeight(32)

  searchBox = safeCreateFrame("EditBox", nil, container, "SearchBoxTemplate", "InputBoxTemplate")
  if searchBox then
    rememberWidget("searchBox", searchBox)
    uiFrame.searchBox = searchBox
    searchBox:SetSize(200, 20)
    searchBox:SetPoint("LEFT", 0, 0)
    searchBox:SetAutoFocus(false)
    if searchBox.Instructions then
      searchBox.Instructions:SetText("Search books...")
    end
    searchBox:SetScript("OnTextChanged", function(box)
      if box.Instructions then
        if box:GetText() ~= "" then
          box.Instructions:Hide()
        else
          box.Instructions:Show()
        end
      end
      ListUI:RebuildFiltered()
      ListUI:UpdateList()
      debugPrint("[BookArchivist] search text changed; rebuild/update")
    end)
  end

  local searchLabel = container:CreateFontString(nil, "OVERLAY", "GameFontNormal")
  searchLabel:SetPoint("LEFT", searchBox, "RIGHT", 10, 0)
  searchLabel:SetText("|cFFFFD100Title, Creator, or Text|r")

  listBlock = safeCreateFrame("Frame", nil, uiFrame, "InsetFrameTemplate")
  if not listBlock then
    logError("Unable to create book list panel.")
    return
  end
  listBlock:SetPoint("TOPLEFT", uiFrame, "TOPLEFT", 4, -65)
  listBlock:SetSize(365, 485)
  uiFrame.listBlock = listBlock

  listHeader = listBlock:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge")
  listHeader:SetPoint("TOPLEFT", listBlock, "TOPLEFT", 8, -8)
  listHeader:SetText("Saved Books")
  uiFrame.listHeader = listHeader

  breadcrumb = listBlock:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
  breadcrumb:SetPoint("TOPLEFT", listHeader, "BOTTOMLEFT", 0, -2)
  breadcrumb:SetPoint("RIGHT", listBlock, "RIGHT", -150, 0)
  breadcrumb:SetJustifyH("LEFT")
  breadcrumb:SetWordWrap(false)
  breadcrumb:SetText("")
  breadcrumb:Hide()
  uiFrame.locationBreadcrumb = breadcrumb

  listSeparator = listBlock:CreateTexture(nil, "ARTWORK")
  listSeparator:SetHeight(1)
  listSeparator:SetPoint("TOPLEFT", listHeader, "BOTTOMLEFT", -4, -4)
  listSeparator:SetPoint("TOPRIGHT", listBlock, "TOPRIGHT", -8, -28)
  listSeparator:SetColorTexture(0.25, 0.25, 0.25, 1)
  uiFrame.listSeparator = listSeparator

  locationsModeButton = safeCreateFrame("Button", nil, listBlock, "UIPanelButtonTemplate")
  if locationsModeButton then
    locationsModeButton:SetSize(88, 22)
    locationsModeButton:SetPoint("TOPRIGHT", listBlock, "TOPRIGHT", -8, -6)
    locationsModeButton:SetText("Locations")
    locationsModeButton:SetScript("OnClick", function()
      setListMode(LIST_MODES.LOCATIONS)
    end)
    uiFrame.locationsModeButton = locationsModeButton
  end

  booksModeButton = safeCreateFrame("Button", nil, listBlock, "UIPanelButtonTemplate")
  if booksModeButton then
    booksModeButton:SetSize(70, 22)
    if locationsModeButton then
      booksModeButton:SetPoint("RIGHT", locationsModeButton, "LEFT", -4, 0)
    else
      booksModeButton:SetPoint("TOPRIGHT", listBlock, "TOPRIGHT", -8, -6)
    end
    booksModeButton:SetText("Books")
    booksModeButton:SetScript("OnClick", function()
      setListMode(LIST_MODES.BOOKS)
    end)
    uiFrame.booksModeButton = booksModeButton
  end

  scrollFrame = safeCreateFrame("ScrollFrame", "BookArchivistListScroll", listBlock, "UIPanelScrollFrameTemplate")
  if not scrollFrame then
    logError("Unable to create list scroll frame.")
    return
  end
  scrollFrame:SetPoint("TOPLEFT", listSeparator, "BOTTOMLEFT", 4, -4)
  scrollFrame:SetPoint("BOTTOMRIGHT", listBlock, "BOTTOMRIGHT", -28, 28)
  uiFrame.scrollFrame = scrollFrame

  scrollChild = CreateFrame("Frame", nil, scrollFrame)
  scrollFrame:SetScrollChild(scrollChild)
  scrollChild:SetSize(336, 1)
  scrollChild:ClearAllPoints()
  scrollChild:SetPoint("TOPLEFT", scrollFrame, "TOPLEFT", 0, 0)
  scrollChild:SetPoint("TOPRIGHT", scrollFrame, "TOPRIGHT", -14, 0)
  rememberWidget("scrollChild", scrollChild)
  uiFrame.scrollChild = scrollChild

  scrollFrame:SetScript("OnMouseWheel", function(self, delta)
    local current = self:GetVerticalScroll()
    local maxScroll = self:GetVerticalScrollRange()
    local newScroll = math.max(0, math.min(maxScroll, current - (delta * ROW_H * 3)))
    self:SetVerticalScroll(newScroll)
  end)

  infoText = listBlock:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
  if infoText then
    infoText:SetPoint("BOTTOM", listBlock, "BOTTOM", 0, 6)
    infoText:SetText("|cFF00FF00Tip:|r Open books normally - pages save automatically")
    rememberWidget("infoText", infoText)
    uiFrame.infoText = infoText
  end

  debugPrint("[BookArchivist] ListUI created")
end

function ListUI:RebuildLocationTree()
  local addon = getAddon()
  if not addon then
    locationState.root = nil
    locationState.rows = {}
    locationState.activeNode = nil
    return
  end
  local db = addon:GetDB()
  locationState.root = buildLocationTreeFromDB(db)
  ensureLocationPathValid()
  rebuildLocationRowsForCurrentNode()
end

function ListUI:UpdateListModeUI()
  local mode = getListMode()
  local ui = getUI()
  if not ui then return end

  if listHeader then
    if mode == LIST_MODES.BOOKS then
      listHeader:SetText("Saved Books")
    else
      listHeader:SetText("Browse by Location")
    end
  end

  if breadcrumb then
    if mode == LIST_MODES.LOCATIONS and locationState.root then
      breadcrumb:SetText("|cFFCCCCCC" .. getLocationBreadcrumbText() .. "|r")
      breadcrumb:Show()
    else
      breadcrumb:SetText("")
      breadcrumb:Hide()
    end
  end

  if listSeparator and listHeader then
    listSeparator:ClearAllPoints()
    local anchorTarget = listHeader
    if mode == LIST_MODES.LOCATIONS and breadcrumb and breadcrumb:IsShown() then
      anchorTarget = breadcrumb
    end
    listSeparator:SetPoint("TOPLEFT", anchorTarget, "BOTTOMLEFT", -4, -4)
    local rightAnchor = listBlock or ui
    listSeparator:SetPoint("TOPRIGHT", rightAnchor, "TOPRIGHT", -8, -28)
  end

  if booksModeButton and locationsModeButton then
    booksModeButton:SetEnabled(mode ~= LIST_MODES.BOOKS)
    locationsModeButton:SetEnabled(mode ~= LIST_MODES.LOCATIONS)
  end
end

function ListUI:RebuildFiltered()
  local filtered = getFilteredKeys()
  wipe(filtered)
  disableDeleteButton()

  local addon = getAddon()
  if not addon then
    debugPrint("[BookArchivist] rebuildFiltered: addon missing")
    logError("BookArchivist addon missing during rebuildFiltered")
    return
  end
  local db = addon:GetDB()
  if not db then
    debugPrint("[BookArchivist] rebuildFiltered: DB missing")
    logError("BookArchivist DB missing during rebuildFiltered")
    return
  end

  local order = db.order or {}
  debugPrint(string.format("[BookArchivist] rebuildFiltered: start (order=%d)", #order))
  local q = getSearchText():gsub("^%s+", ""):gsub("%s+$", "")

  local selectedKey = getSelectedKey()
  local selectionStillValid = false

  for _, key in ipairs(order) do
    local entry = db.books[key]
    if entry and matches(entry, q) then
      table.insert(filtered, key)
      if key == selectedKey then
        selectionStillValid = true
      end
    end
  end

  debugPrint(string.format("[BookArchivist] rebuildFiltered: %d matched of %d", #filtered, #order))

  if selectedKey and not selectionStillValid then
    setSelectedKey(nil)
    notifySelectionChanged()
  end
end

function ListUI:UpdateList()
  local ui = getUI()
  if not ui or not scrollChild then
    debugPrint("[BookArchivist] updateList skipped (UI missing)")
    return
  end

  local addon = getAddon()
  if not addon then
    debugPrint("[BookArchivist] updateList: addon missing")
    return
  end
  local db = addon:GetDB()
  if not db then
    debugPrint("[BookArchivist] updateList: DB missing")
    return
  end

  local mode = getListMode()
  self:UpdateListModeUI()
  ButtonPool:ReleaseAll()

  local info = ensureInfoText()

  if mode == LIST_MODES.BOOKS then
    local filtered = getFilteredKeys()
    local total = #filtered
    local dbCount = db.order and #db.order or 0
    debugPrint(string.format("[BookArchivist] updateList filtered=%d totalDB=%d", total, dbCount))

    local totalHeight = math.max(1, total * ROW_H)
    scrollChild:SetSize(336, totalHeight)

    for i = 1, total do
      local button = ButtonPool:Acquire()
      button:SetPoint("TOPLEFT", 0, -(i-1) * ROW_H)

      local key = filtered[i]
      if key then
        local entry = db.books[key]
        if entry then
          button.bookKey = key
          button.itemKind = "book"
          button.text:SetText(entryToDisplay(entry))

          if key == getSelectedKey() then
            button.selected:Show()
            button.selectedEdge:Show()
          else
            button.selected:Hide()
            button.selectedEdge:Hide()
          end
        end
      end
    end

    local countText = string.format("|cFFFFD100%d|r book%s", total, total ~= 1 and "s" or "")
    if total ~= #(db.order or {}) then
      countText = countText .. string.format(" (filtered from |cFFFFD100%d|r)", #(db.order or {}))
    end
    if info then
      info:SetText(countText)
    end
    return
  end

  local rows = locationState.rows or {}
  local total = #rows
  scrollChild:SetSize(336, math.max(1, total * ROW_H))
  local activeNode = locationState.activeNode or locationState.root

  for i = 1, total do
    local row = rows[i]
    local button = ButtonPool:Acquire()
    button:SetPoint("TOPLEFT", 0, -(i-1) * ROW_H)
    button.itemKind = row.kind

    if row.kind == "back" then
      button.locationName = nil
      button.bookKey = nil
      button.text:SetText("|cFF00FF00âŸµ Back|r\n|cFF999999Up one level|r")
      button.selected:Hide()
      button.selectedEdge:Hide()
    elseif row.kind == "location" then
      button.locationName = row.name
      button.bookKey = nil
      local childNode = row.node
      local childCount = childNode and childNode.childNames and #childNode.childNames or 0
      local bookCount = childNode and childNode.books and #childNode.books or 0
      local detail
      if childCount > 0 then
        detail = string.format("%d sub-location%s", childCount, childCount ~= 1 and "s" or "")
      elseif bookCount > 0 then
        detail = string.format("%d book%s", bookCount, bookCount ~= 1 and "s" or "")
      else
        detail = "Empty location"
      end
      button.text:SetText(string.format("|cFFFFD100%s|r\n|cFF999999%s|r", row.name, detail))
      button.selected:Hide()
      button.selectedEdge:Hide()
    elseif row.kind == "book" then
      local key = row.key
      button.bookKey = key
      button.locationName = nil
      local entry = key and db.books and db.books[key]
      button.text:SetText(entry and entryToDisplay(entry) or "|cFFFFD100Unknown Book|r")
      if key == getSelectedKey() then
        button.selected:Show()
        button.selectedEdge:Show()
      else
        button.selected:Hide()
        button.selectedEdge:Hide()
      end
    else
      button.text:SetText("?")
      button.selected:Hide()
      button.selectedEdge:Hide()
    end
  end

  local infoMessage
  if not activeNode or (total == 0 and (#(locationState.path or {}) == 0)) then
    infoMessage = "|cFF888888No saved locations yet|r"
  else
    local hasChildren = activeNode.childNames and #activeNode.childNames > 0
    if hasChildren then
      local count = #activeNode.childNames
      infoMessage = string.format("|cFFFFD100%d|r location%s", count, count ~= 1 and "s" or "")
    else
      local count = activeNode.books and #activeNode.books or 0
      infoMessage = string.format("|cFFFFD100%d|r book%s in this location", count, count ~= 1 and "s" or "")
    end
  end

  if info then
    info:SetText(infoMessage)
  end
end

function ListUI:GetRowHeight()
  return ROW_H
end
